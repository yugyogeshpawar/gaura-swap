{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { addMulticallListeners, errorFetchingMulticallResults, fetchingMulticallResults, removeMulticallListeners, toCallKey, updateMulticallResults } from './actions';\nconst initialState = {\n  callResults: {}\n};\nexport default createReducer(initialState, builder => builder.addCase(addMulticallListeners, (state, _ref) => {\n  var _listeners$chainId;\n\n  let {\n    payload: {\n      calls,\n      chainId,\n      options: {\n        blocksPerFetch = 1\n      } = {}\n    }\n  } = _ref;\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  listeners[chainId] = (_listeners$chainId = listeners[chainId]) !== null && _listeners$chainId !== void 0 ? _listeners$chainId : {};\n  calls.forEach(call => {\n    var _listeners$chainId$ca, _listeners$chainId$ca2;\n\n    const callKey = toCallKey(call);\n    listeners[chainId][callKey] = (_listeners$chainId$ca = listeners[chainId][callKey]) !== null && _listeners$chainId$ca !== void 0 ? _listeners$chainId$ca : {};\n    listeners[chainId][callKey][blocksPerFetch] = ((_listeners$chainId$ca2 = listeners[chainId][callKey][blocksPerFetch]) !== null && _listeners$chainId$ca2 !== void 0 ? _listeners$chainId$ca2 : 0) + 1;\n  });\n}).addCase(removeMulticallListeners, (state, _ref2) => {\n  let {\n    payload: {\n      chainId,\n      calls,\n      options: {\n        blocksPerFetch = 1\n      } = {}\n    }\n  } = _ref2;\n  const listeners = state.callListeners ? state.callListeners : state.callListeners = {};\n  if (!listeners[chainId]) return;\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    if (!listeners[chainId][callKey]) return;\n    if (!listeners[chainId][callKey][blocksPerFetch]) return;\n\n    if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n      delete listeners[chainId][callKey][blocksPerFetch];\n    } else {\n      listeners[chainId][callKey][blocksPerFetch]--;\n    }\n  });\n}).addCase(fetchingMulticallResults, (state, _ref3) => {\n  var _state$callResults$ch;\n\n  let {\n    payload: {\n      chainId,\n      fetchingBlockNumber,\n      calls\n    }\n  } = _ref3;\n  state.callResults[chainId] = (_state$callResults$ch = state.callResults[chainId]) !== null && _state$callResults$ch !== void 0 ? _state$callResults$ch : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n\n    if (!current) {\n      state.callResults[chainId][callKey] = {\n        fetchingBlockNumber\n      };\n    } else {\n      var _current$fetchingBloc;\n\n      if (((_current$fetchingBloc = current.fetchingBlockNumber) !== null && _current$fetchingBloc !== void 0 ? _current$fetchingBloc : 0) >= fetchingBlockNumber) return;\n      state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(errorFetchingMulticallResults, (state, _ref4) => {\n  var _state$callResults$ch2;\n\n  let {\n    payload: {\n      fetchingBlockNumber,\n      chainId,\n      calls\n    }\n  } = _ref4;\n  state.callResults[chainId] = (_state$callResults$ch2 = state.callResults[chainId]) !== null && _state$callResults$ch2 !== void 0 ? _state$callResults$ch2 : {};\n  calls.forEach(call => {\n    const callKey = toCallKey(call);\n    const current = state.callResults[chainId][callKey];\n    if (!current) return; // only should be dispatched if we are already fetching\n\n    if (current.fetchingBlockNumber === fetchingBlockNumber) {\n      delete current.fetchingBlockNumber;\n      current.data = null;\n      current.blockNumber = fetchingBlockNumber;\n    }\n  });\n}).addCase(updateMulticallResults, (state, _ref5) => {\n  var _state$callResults$ch3;\n\n  let {\n    payload: {\n      chainId,\n      results,\n      blockNumber\n    }\n  } = _ref5;\n  state.callResults[chainId] = (_state$callResults$ch3 = state.callResults[chainId]) !== null && _state$callResults$ch3 !== void 0 ? _state$callResults$ch3 : {};\n  Object.keys(results).forEach(callKey => {\n    var _current$blockNumber;\n\n    const current = state.callResults[chainId][callKey];\n    if (((_current$blockNumber = current === null || current === void 0 ? void 0 : current.blockNumber) !== null && _current$blockNumber !== void 0 ? _current$blockNumber : 0) > blockNumber) return;\n    state.callResults[chainId][callKey] = {\n      data: results[callKey],\n      blockNumber\n    };\n  });\n}));","map":{"version":3,"names":["createReducer","addMulticallListeners","errorFetchingMulticallResults","fetchingMulticallResults","removeMulticallListeners","toCallKey","updateMulticallResults","initialState","callResults","builder","addCase","state","payload","calls","chainId","options","blocksPerFetch","listeners","callListeners","forEach","call","callKey","fetchingBlockNumber","current","data","blockNumber","results","Object","keys"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/state/multicall/reducer.ts"],"sourcesContent":["import { createReducer } from '@reduxjs/toolkit';\nimport {\n  addMulticallListeners,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  removeMulticallListeners,\n  toCallKey,\n  updateMulticallResults,\n} from './actions';\n\nexport interface MulticallState {\n  callListeners?: {\n    // on a per-chain basis\n    [chainId: number]: {\n      // stores for each call key the listeners' preferences\n      [callKey: string]: {\n        // stores how many listeners there are per each blocks per fetch preference\n        [blocksPerFetch: number]: number;\n      };\n    };\n  };\n\n  callResults: {\n    [chainId: number]: {\n      [callKey: string]: {\n        data?: string | null;\n        blockNumber?: number;\n        fetchingBlockNumber?: number;\n      };\n    };\n  };\n}\n\nconst initialState: MulticallState = {\n  callResults: {},\n};\n\nexport default createReducer(initialState, (builder) =>\n  builder\n    .addCase(addMulticallListeners, (state, { payload: { calls, chainId, options: { blocksPerFetch = 1 } = {} } }) => {\n      const listeners: MulticallState['callListeners'] = state.callListeners\n        ? state.callListeners\n        : (state.callListeners = {});\n      listeners[chainId] = listeners[chainId] ?? {};\n      calls.forEach((call) => {\n        const callKey = toCallKey(call);\n        listeners[chainId][callKey] = listeners[chainId][callKey] ?? {};\n        listeners[chainId][callKey][blocksPerFetch] = (listeners[chainId][callKey][blocksPerFetch] ?? 0) + 1;\n      });\n    })\n    .addCase(\n      removeMulticallListeners,\n      (state, { payload: { chainId, calls, options: { blocksPerFetch = 1 } = {} } }) => {\n        const listeners: MulticallState['callListeners'] = state.callListeners\n          ? state.callListeners\n          : (state.callListeners = {});\n\n        if (!listeners[chainId]) return;\n        calls.forEach((call) => {\n          const callKey = toCallKey(call);\n          if (!listeners[chainId][callKey]) return;\n          if (!listeners[chainId][callKey][blocksPerFetch]) return;\n\n          if (listeners[chainId][callKey][blocksPerFetch] === 1) {\n            delete listeners[chainId][callKey][blocksPerFetch];\n          } else {\n            listeners[chainId][callKey][blocksPerFetch]--;\n          }\n        });\n      }\n    )\n    .addCase(fetchingMulticallResults, (state, { payload: { chainId, fetchingBlockNumber, calls } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {};\n      calls.forEach((call) => {\n        const callKey = toCallKey(call);\n        const current = state.callResults[chainId][callKey];\n        if (!current) {\n          state.callResults[chainId][callKey] = {\n            fetchingBlockNumber,\n          };\n        } else {\n          if ((current.fetchingBlockNumber ?? 0) >= fetchingBlockNumber) return;\n          state.callResults[chainId][callKey].fetchingBlockNumber = fetchingBlockNumber;\n        }\n      });\n    })\n    .addCase(errorFetchingMulticallResults, (state, { payload: { fetchingBlockNumber, chainId, calls } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {};\n      calls.forEach((call) => {\n        const callKey = toCallKey(call);\n        const current = state.callResults[chainId][callKey];\n        if (!current) return; // only should be dispatched if we are already fetching\n        if (current.fetchingBlockNumber === fetchingBlockNumber) {\n          delete current.fetchingBlockNumber;\n          current.data = null;\n          current.blockNumber = fetchingBlockNumber;\n        }\n      });\n    })\n    .addCase(updateMulticallResults, (state, { payload: { chainId, results, blockNumber } }) => {\n      state.callResults[chainId] = state.callResults[chainId] ?? {};\n      Object.keys(results).forEach((callKey) => {\n        const current = state.callResults[chainId][callKey];\n        if ((current?.blockNumber ?? 0) > blockNumber) return;\n        state.callResults[chainId][callKey] = {\n          data: results[callKey],\n          blockNumber,\n        };\n      });\n    })\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
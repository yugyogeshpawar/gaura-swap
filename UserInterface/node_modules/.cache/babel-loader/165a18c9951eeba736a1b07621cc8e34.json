{"ast":null,"code":"import { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\n\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\n\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\n\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n}; // use this options object\n\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n}; // the lowest level call for subscribing to contract data\n\nfunction useCallsData(calls, options) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]); // update listeners when there is an actual change that persists for at least 100ms\n\n  useEffect(() => {\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    const calls = callKeys.map(key => parseCallKey(key));\n    dispatch(addMulticallListeners({\n      chainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$chainId;\n\n    if (!chainId || !call) return INVALID_RESULT;\n    const result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n    let data;\n\n    if ((result === null || result === void 0 ? void 0 : result.data) && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      data = result.data;\n    }\n\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, chainId]);\n}\n\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\n\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result = undefined;\n\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success\n  };\n}\n\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}","map":{"version":3,"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","chainId","callResults","state","multicall","dispatch","serializedCallKeys","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/state/multicall/hooks.ts"],"sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { Contract } from '@ethersproject/contracts';\nimport { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useBlockNumber } from '../application/hooks';\nimport { AppDispatch, AppState } from '../index';\nimport {\n  addMulticallListeners,\n  Call,\n  removeMulticallListeners,\n  parseCallKey,\n  toCallKey,\n  ListenerOptions,\n} from './actions';\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any;\n}\n\ntype MethodArg = string | number | BigNumber;\ntype MethodArgs = Array<MethodArg | MethodArg[]>;\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined;\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  );\n}\n\ninterface CallResult {\n  readonly valid: boolean;\n  readonly data: string | undefined;\n  readonly blockNumber: number | undefined;\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined };\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n};\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { chainId } = useActiveWeb3React();\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\n    (state) => state.multicall.callResults\n  );\n  const dispatch = useDispatch<AppDispatch>();\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? []\n      ),\n    [calls]\n  );\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    const calls = callKeys.map((key) => parseCallKey(key));\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options,\n      })\n    );\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options,\n        })\n      );\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>((call) => {\n        if (!chainId || !call) return INVALID_RESULT;\n\n        const result = callResults[chainId]?.[toCallKey(call)];\n        let data;\n        if (result?.data && result?.data !== '0x') {\n          data = result.data;\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber };\n      }),\n    [callResults, calls, chainId]\n  );\n}\n\ninterface CallState {\n  readonly valid: boolean;\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined;\n  // true if the result has never been fetched\n  readonly loading: boolean;\n  // true if the result is not for the latest block\n  readonly syncing: boolean;\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean;\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false };\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false };\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE;\n  const { valid, data, blockNumber } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber ?? 0) < latestBlockNumber;\n  let result: Result | undefined = undefined;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result: result,\n    error: !success,\n  };\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName]);\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>((inputs) => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\n            };\n          })\n        : [],\n    [callInputs, contract, fragment]\n  );\n\n  const results = useCallsData(calls, options);\n\n  const latestBlockNumber = useBlockNumber();\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment]\n  );\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>((address) => {\n            return address && callData\n              ? {\n                  address,\n                  callData,\n                }\n              : undefined;\n          })\n        : [],\n    [addresses, callData, fragment]\n  );\n\n  const results = useCallsData(calls, options);\n\n  const latestBlockNumber = useBlockNumber();\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName]);\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\n          },\n        ]\n      : [];\n  }, [contract, fragment, inputs]);\n\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
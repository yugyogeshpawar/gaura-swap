{"ast":null,"code":"import useENS from '../../hooks/useENS';\nimport { parseUnits } from '@ethersproject/units';\nimport { CurrencyAmount, ETHER, JSBI, Token, TokenAmount } from '@uniswap/sdk';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useCurrency } from '../../hooks/Tokens';\nimport { useTradeExactIn, useTradeExactOut } from '../../hooks/Trades';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport { isAddress } from '../../utils';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nimport { useUserSlippageTolerance } from '../user/hooks';\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices';\nimport { FACTORY_ADDRESS, ROUTER_ADDRESS } from '../../constants';\nexport function useSwapState() {\n  return useSelector(state => state.swap);\n}\nexport function useSwapActionHandlers() {\n  const dispatch = useDispatch();\n  const onCurrencySelection = useCallback((field, currency) => {\n    dispatch(selectCurrency({\n      field,\n      currencyId: currency instanceof Token ? currency.address : currency === ETHER ? 'ETH' : ''\n    }));\n  }, [dispatch]);\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n  const onUserInput = useCallback((field, typedValue) => {\n    dispatch(typeInput({\n      field,\n      typedValue\n    }));\n  }, [dispatch]);\n  const onChangeRecipient = useCallback(recipient => {\n    dispatch(setRecipient({\n      recipient\n    }));\n  }, [dispatch]);\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient\n  };\n} // try to parse a user entered amount for a given token\n\nexport function tryParseAmount(value, currency) {\n  if (!value || !currency) {\n    return undefined;\n  }\n\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n\n    if (typedValueParsed !== '0') {\n      return currency instanceof Token ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed)) : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  } // necessary for all paths to return a value\n\n\n  return undefined;\n}\nconst BAD_RECIPIENT_ADDRESSES = [FACTORY_ADDRESS, ROUTER_ADDRESS];\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\n\nfunction involvesAddress(trade, checksummedAddress) {\n  return trade.route.path.some(token => token.address === checksummedAddress) || trade.route.pairs.some(pair => pair.liquidityToken.address === checksummedAddress);\n} // from the current swap inputs, compute the best trade and return it.\n\n\nexport function useDerivedSwapInfo() {\n  var _ref, _ref2;\n\n  const {\n    account\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: {\n      currencyId: inputCurrencyId\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrencyId\n    },\n    recipient\n  } = useSwapState();\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientLookup = useENS(recipient !== null && recipient !== void 0 ? recipient : undefined);\n  const to = (_ref = recipient === null ? account : recipientLookup.address) !== null && _ref !== void 0 ? _ref : null;\n  const relevantTokenBalances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined]);\n  const isExactIn = independentField === Field.INPUT;\n  const parsedAmount = tryParseAmount(typedValue, (_ref2 = isExactIn ? inputCurrency : outputCurrency) !== null && _ref2 !== void 0 ? _ref2 : undefined);\n  const bestTradeExactIn = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined);\n  const bestTradeExactOut = useTradeExactOut(inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined, !isExactIn ? parsedAmount : undefined);\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1]\n  };\n  const currencies = {\n    [Field.INPUT]: inputCurrency !== null && inputCurrency !== void 0 ? inputCurrency : undefined,\n    [Field.OUTPUT]: outputCurrency !== null && outputCurrency !== void 0 ? outputCurrency : undefined\n  };\n  let inputError;\n\n  if (!account) {\n    inputError = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    var _inputError;\n\n    inputError = (_inputError = inputError) !== null && _inputError !== void 0 ? _inputError : 'Enter an amount';\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    var _inputError2;\n\n    inputError = (_inputError2 = inputError) !== null && _inputError2 !== void 0 ? _inputError2 : 'Select a token';\n  }\n\n  const formattedTo = isAddress(to);\n\n  if (!to || !formattedTo) {\n    var _inputError3;\n\n    inputError = (_inputError3 = inputError) !== null && _inputError3 !== void 0 ? _inputError3 : 'Enter a recipient';\n  } else {\n    if (BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 || bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo) || bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo)) {\n      var _inputError4;\n\n      inputError = (_inputError4 = inputError) !== null && _inputError4 !== void 0 ? _inputError4 : 'Invalid recipient';\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance();\n  const slippageAdjustedAmounts = v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage); // compare input balance to max input based on version\n\n  const [balanceIn, amountIn] = [currencyBalances[Field.INPUT], slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null];\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance';\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade !== null && v2Trade !== void 0 ? v2Trade : undefined,\n    inputError\n  };\n}\n\nfunction parseCurrencyFromURLParameter(urlParam) {\n  var _ETH;\n\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'ETH') return 'ETH';\n    if (valid === false) return 'ETH';\n  }\n\n  return (_ETH = 'ETH') !== null && _ETH !== void 0 ? _ETH : 'as';\n}\n\nfunction parseTokenAmountURLParameter(urlParam) {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\n\nfunction parseIndependentFieldURLParameter(urlParam) {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nfunction validatedRecipient(recipient) {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs) {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient\n  };\n} // updates the swap state to use the defaults for a given network\n\nexport function useDefaultsFromURLSearch() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const dispatch = useDispatch();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState();\n  useEffect(() => {\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n    dispatch(replaceSwapState({\n      typedValue: parsed.typedValue,\n      field: parsed.independentField,\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n      recipient: parsed.recipient\n    }));\n    setResult({\n      inputCurrencyId: parsed[Field.INPUT].currencyId,\n      outputCurrencyId: parsed[Field.OUTPUT].currencyId\n    }); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n  return result;\n}","map":{"version":3,"names":["useENS","parseUnits","CurrencyAmount","ETHER","JSBI","Token","TokenAmount","useCallback","useEffect","useState","useDispatch","useSelector","useActiveWeb3React","useCurrency","useTradeExactIn","useTradeExactOut","useParsedQueryString","isAddress","useCurrencyBalances","Field","replaceSwapState","selectCurrency","setRecipient","switchCurrencies","typeInput","useUserSlippageTolerance","computeSlippageAdjustedAmounts","FACTORY_ADDRESS","ROUTER_ADDRESS","useSwapState","state","swap","useSwapActionHandlers","dispatch","onCurrencySelection","field","currency","currencyId","address","onSwitchTokens","onUserInput","typedValue","onChangeRecipient","recipient","tryParseAmount","value","undefined","typedValueParsed","decimals","toString","BigInt","ether","error","console","debug","BAD_RECIPIENT_ADDRESSES","involvesAddress","trade","checksummedAddress","route","path","some","token","pairs","pair","liquidityToken","useDerivedSwapInfo","account","independentField","INPUT","inputCurrencyId","OUTPUT","outputCurrencyId","inputCurrency","outputCurrency","recipientLookup","to","relevantTokenBalances","isExactIn","parsedAmount","bestTradeExactIn","bestTradeExactOut","v2Trade","currencyBalances","currencies","inputError","formattedTo","indexOf","allowedSlippage","slippageAdjustedAmounts","balanceIn","amountIn","lessThan","symbol","parseCurrencyFromURLParameter","urlParam","valid","toUpperCase","parseTokenAmountURLParameter","isNaN","parseFloat","parseIndependentFieldURLParameter","toLowerCase","ENS_NAME_REGEX","ADDRESS_REGEX","validatedRecipient","test","queryParametersToSwapState","parsedQs","exactAmount","exactField","useDefaultsFromURLSearch","chainId","result","setResult","parsed"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/state/swap/hooks.ts"],"sourcesContent":["import useENS from '../../hooks/useENS';\nimport { parseUnits } from '@ethersproject/units';\nimport { Currency, CurrencyAmount, ETHER, JSBI, Token, TokenAmount, Trade } from '@uniswap/sdk';\nimport { ParsedQs } from 'qs';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useCurrency } from '../../hooks/Tokens';\nimport { useTradeExactIn, useTradeExactOut } from '../../hooks/Trades';\nimport useParsedQueryString from '../../hooks/useParsedQueryString';\nimport { isAddress } from '../../utils';\nimport { AppDispatch, AppState } from '../index';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, replaceSwapState, selectCurrency, setRecipient, switchCurrencies, typeInput } from './actions';\nimport { SwapState } from './reducer';\nimport { useUserSlippageTolerance } from '../user/hooks';\nimport { computeSlippageAdjustedAmounts } from '../../utils/prices';\nimport { FACTORY_ADDRESS, ROUTER_ADDRESS } from '../../constants';\n\nexport function useSwapState(): AppState['swap'] {\n  return useSelector<AppState, AppState['swap']>((state) => state.swap);\n}\n\nexport function useSwapActionHandlers(): {\n  onCurrencySelection: (field: Field, currency: Currency) => void;\n  onSwitchTokens: () => void;\n  onUserInput: (field: Field, typedValue: string) => void;\n  onChangeRecipient: (recipient: string | null) => void;\n} {\n  const dispatch = useDispatch<AppDispatch>();\n  const onCurrencySelection = useCallback(\n    (field: Field, currency: Currency) => {\n      dispatch(\n        selectCurrency({\n          field,\n          currencyId: currency instanceof Token ? currency.address : currency === ETHER ? 'ETH' : '',\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const onSwitchTokens = useCallback(() => {\n    dispatch(switchCurrencies());\n  }, [dispatch]);\n\n  const onUserInput = useCallback(\n    (field: Field, typedValue: string) => {\n      dispatch(typeInput({ field, typedValue }));\n    },\n    [dispatch]\n  );\n\n  const onChangeRecipient = useCallback(\n    (recipient: string | null) => {\n      dispatch(setRecipient({ recipient }));\n    },\n    [dispatch]\n  );\n\n  return {\n    onSwitchTokens,\n    onCurrencySelection,\n    onUserInput,\n    onChangeRecipient,\n  };\n}\n\n// try to parse a user entered amount for a given token\nexport function tryParseAmount(value?: string, currency?: Currency): CurrencyAmount | undefined {\n  if (!value || !currency) {\n    return undefined;\n  }\n  try {\n    const typedValueParsed = parseUnits(value, currency.decimals).toString();\n    if (typedValueParsed !== '0') {\n      return currency instanceof Token\n        ? new TokenAmount(currency, JSBI.BigInt(typedValueParsed))\n        : CurrencyAmount.ether(JSBI.BigInt(typedValueParsed));\n    }\n  } catch (error) {\n    // should fail if the user specifies too many decimal places of precision (or maybe exceed max uint?)\n    console.debug(`Failed to parse input amount: \"${value}\"`, error);\n  }\n  // necessary for all paths to return a value\n  return undefined;\n}\n\nconst BAD_RECIPIENT_ADDRESSES: string[] = [FACTORY_ADDRESS, ROUTER_ADDRESS];\n\n/**\n * Returns true if any of the pairs or tokens in a trade have the given checksummed address\n * @param trade to check for the given address\n * @param checksummedAddress address to check in the pairs and tokens\n */\nfunction involvesAddress(trade: Trade, checksummedAddress: string): boolean {\n  return (\n    trade.route.path.some((token) => token.address === checksummedAddress) ||\n    trade.route.pairs.some((pair) => pair.liquidityToken.address === checksummedAddress)\n  );\n}\n\n// from the current swap inputs, compute the best trade and return it.\nexport function useDerivedSwapInfo(): {\n  currencies: { [field in Field]?: Currency };\n  currencyBalances: { [field in Field]?: CurrencyAmount };\n  parsedAmount: CurrencyAmount | undefined;\n  v2Trade: Trade | undefined;\n  inputError?: string;\n} {\n  const { account } = useActiveWeb3React();\n\n  const {\n    independentField,\n    typedValue,\n    [Field.INPUT]: { currencyId: inputCurrencyId },\n    [Field.OUTPUT]: { currencyId: outputCurrencyId },\n    recipient,\n  } = useSwapState();\n\n  const inputCurrency = useCurrency(inputCurrencyId);\n  const outputCurrency = useCurrency(outputCurrencyId);\n  const recipientLookup = useENS(recipient ?? undefined);\n  const to: string | null = (recipient === null ? account : recipientLookup.address) ?? null;\n\n  const relevantTokenBalances = useCurrencyBalances(account ?? undefined, [\n    inputCurrency ?? undefined,\n    outputCurrency ?? undefined,\n  ]);\n\n  const isExactIn: boolean = independentField === Field.INPUT;\n  const parsedAmount = tryParseAmount(typedValue, (isExactIn ? inputCurrency : outputCurrency) ?? undefined);\n\n  const bestTradeExactIn = useTradeExactIn(isExactIn ? parsedAmount : undefined, outputCurrency ?? undefined);\n  const bestTradeExactOut = useTradeExactOut(inputCurrency ?? undefined, !isExactIn ? parsedAmount : undefined);\n\n  const v2Trade = isExactIn ? bestTradeExactIn : bestTradeExactOut;\n\n  const currencyBalances = {\n    [Field.INPUT]: relevantTokenBalances[0],\n    [Field.OUTPUT]: relevantTokenBalances[1],\n  };\n\n  const currencies: { [field in Field]?: Currency } = {\n    [Field.INPUT]: inputCurrency ?? undefined,\n    [Field.OUTPUT]: outputCurrency ?? undefined,\n  };\n\n  let inputError: string | undefined;\n  if (!account) {\n    inputError = 'Connect Wallet';\n  }\n\n  if (!parsedAmount) {\n    inputError = inputError ?? 'Enter an amount';\n  }\n\n  if (!currencies[Field.INPUT] || !currencies[Field.OUTPUT]) {\n    inputError = inputError ?? 'Select a token';\n  }\n\n  const formattedTo = isAddress(to);\n  if (!to || !formattedTo) {\n    inputError = inputError ?? 'Enter a recipient';\n  } else {\n    if (\n      BAD_RECIPIENT_ADDRESSES.indexOf(formattedTo) !== -1 ||\n      (bestTradeExactIn && involvesAddress(bestTradeExactIn, formattedTo)) ||\n      (bestTradeExactOut && involvesAddress(bestTradeExactOut, formattedTo))\n    ) {\n      inputError = inputError ?? 'Invalid recipient';\n    }\n  }\n\n  const [allowedSlippage] = useUserSlippageTolerance();\n\n  const slippageAdjustedAmounts =\n    v2Trade && allowedSlippage && computeSlippageAdjustedAmounts(v2Trade, allowedSlippage);\n\n  // compare input balance to max input based on version\n  const [balanceIn, amountIn] = [\n    currencyBalances[Field.INPUT],\n    slippageAdjustedAmounts ? slippageAdjustedAmounts[Field.INPUT] : null,\n  ];\n\n  if (balanceIn && amountIn && balanceIn.lessThan(amountIn)) {\n    inputError = 'Insufficient ' + amountIn.currency.symbol + ' balance';\n  }\n\n  return {\n    currencies,\n    currencyBalances,\n    parsedAmount,\n    v2Trade: v2Trade ?? undefined,\n    inputError,\n  };\n}\n\nfunction parseCurrencyFromURLParameter(urlParam: any): string {\n  if (typeof urlParam === 'string') {\n    const valid = isAddress(urlParam);\n    if (valid) return valid;\n    if (urlParam.toUpperCase() === 'ETH') return 'ETH';\n    if (valid === false) return 'ETH';\n  }\n  return 'ETH' ?? 'as';\n}\n\nfunction parseTokenAmountURLParameter(urlParam: any): string {\n  return typeof urlParam === 'string' && !isNaN(parseFloat(urlParam)) ? urlParam : '';\n}\n\nfunction parseIndependentFieldURLParameter(urlParam: any): Field {\n  return typeof urlParam === 'string' && urlParam.toLowerCase() === 'output' ? Field.OUTPUT : Field.INPUT;\n}\n\nconst ENS_NAME_REGEX = /^[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)?$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\nfunction validatedRecipient(recipient: any): string | null {\n  if (typeof recipient !== 'string') return null;\n  const address = isAddress(recipient);\n  if (address) return address;\n  if (ENS_NAME_REGEX.test(recipient)) return recipient;\n  if (ADDRESS_REGEX.test(recipient)) return recipient;\n  return null;\n}\n\nexport function queryParametersToSwapState(parsedQs: ParsedQs): SwapState {\n  let inputCurrency = parseCurrencyFromURLParameter(parsedQs.inputCurrency);\n  let outputCurrency = parseCurrencyFromURLParameter(parsedQs.outputCurrency);\n  if (inputCurrency === outputCurrency) {\n    if (typeof parsedQs.outputCurrency === 'string') {\n      inputCurrency = '';\n    } else {\n      outputCurrency = '';\n    }\n  }\n\n  const recipient = validatedRecipient(parsedQs.recipient);\n\n  return {\n    [Field.INPUT]: {\n      currencyId: inputCurrency,\n    },\n    [Field.OUTPUT]: {\n      currencyId: outputCurrency,\n    },\n    typedValue: parseTokenAmountURLParameter(parsedQs.exactAmount),\n    independentField: parseIndependentFieldURLParameter(parsedQs.exactField),\n    recipient,\n  };\n}\n\n// updates the swap state to use the defaults for a given network\nexport function useDefaultsFromURLSearch():\n  | { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined }\n  | undefined {\n  const { chainId } = useActiveWeb3React();\n  const dispatch = useDispatch<AppDispatch>();\n  const parsedQs = useParsedQueryString();\n  const [result, setResult] = useState<\n    { inputCurrencyId: string | undefined; outputCurrencyId: string | undefined } | undefined\n  >();\n\n  useEffect(() => {\n    if (!chainId) return;\n    const parsed = queryParametersToSwapState(parsedQs);\n\n    dispatch(\n      replaceSwapState({\n        typedValue: parsed.typedValue,\n        field: parsed.independentField,\n        inputCurrencyId: parsed[Field.INPUT].currencyId,\n        outputCurrencyId: parsed[Field.OUTPUT].currencyId,\n        recipient: parsed.recipient,\n      })\n    );\n\n    setResult({ inputCurrencyId: parsed[Field.INPUT].currencyId, outputCurrencyId: parsed[Field.OUTPUT].currencyId });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [dispatch, chainId]);\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
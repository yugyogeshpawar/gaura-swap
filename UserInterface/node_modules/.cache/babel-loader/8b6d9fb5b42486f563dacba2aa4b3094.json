{"ast":null,"code":"import { useDefaultTokenList } from './../state/lists/hooks';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { ETHER, Token, currencyEquals } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useCombinedActiveList, useCombinedInactiveList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useActiveWeb3React } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { filterTokens } from '../components/SearchModal/filtering';\nimport { arrayify } from 'ethers/lib/utils'; // reduce token map into standard address <-> Token mapping, optionally include user added tokens\n\nfunction useTokensFromMap(tokenMap, includeUserAdded) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  return useMemo(() => {\n    if (!chainId) return {}; // reduce to just tokens\n\n    const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce((newMap, address) => {\n      newMap[address] = tokenMap[chainId][address].token;\n      return newMap;\n    }, {});\n\n    if (includeUserAdded) {\n      return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n      .reduce((tokenMap, token) => {\n        tokenMap[token.address] = token;\n        return tokenMap;\n      }, // must make a copy because reduce modifies the map, and we do not\n      // want to make a copy in every iteration\n      { ...mapWithoutUrls\n      });\n    }\n\n    return mapWithoutUrls;\n  }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n}\n\nexport function useDefaultTokens() {\n  const defaultList = useDefaultTokenList();\n  return useTokensFromMap(defaultList, false);\n}\nexport function useAllTokens() {\n  const allTokens = useCombinedActiveList();\n  return useTokensFromMap(allTokens, true);\n}\nexport function useAllInactiveTokens() {\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false); // filter out any token that are on active list\n\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses ? Object.keys(inactiveTokens).reduce((newMap, address) => {\n    if (!activeTokensAddresses.includes(address)) {\n      newMap[address] = inactiveTokens[address];\n    }\n\n    return newMap;\n  }, {}) : inactiveTokens;\n  return filteredInactive;\n}\nexport function useIsTokenActive(token) {\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n} // used to detect extra search results\n\nexport function useFoundOnInactiveList(searchQuery) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n  return useMemo(() => {\n    if (!chainId || searchQuery === '') {\n      return undefined;\n    } else {\n      const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n      return tokens;\n    }\n  }, [chainId, inactiveTokens, searchQuery]);\n} // Check if currency is included in custom list from user storage\n\nexport function useIsUserAddedToken(currency) {\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n} // parse a name or symbol from a token response\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : // need to check for proper bytes string and valid terminator\n  bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0 ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens();\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\nexport function useCurrency(currencyId) {\n  const isETH = (currencyId === null || currencyId === void 0 ? void 0 : currencyId.toUpperCase()) === 'GAU';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}","map":{"version":3,"names":["useDefaultTokenList","parseBytes32String","ETHER","Token","currencyEquals","useMemo","useCombinedActiveList","useCombinedInactiveList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","filterTokens","arrayify","useTokensFromMap","tokenMap","includeUserAdded","chainId","userAddedTokens","mapWithoutUrls","Object","keys","reduce","newMap","address","token","useDefaultTokens","defaultList","useAllTokens","allTokens","useAllInactiveTokens","inactiveTokensMap","inactiveTokens","activeTokensAddresses","filteredInactive","includes","useIsTokenActive","activeTokens","useFoundOnInactiveList","searchQuery","undefined","tokens","values","useIsUserAddedToken","currency","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","tokenContract","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useCurrency","currencyId","isETH","toUpperCase"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/hooks/Tokens.ts"],"sourcesContent":["import { TokenAddressMap, useDefaultTokenList } from './../state/lists/hooks';\nimport { parseBytes32String } from '@ethersproject/strings';\nimport { Currency, ETHER, Token, currencyEquals } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useCombinedActiveList, useCombinedInactiveList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\n\nimport { useActiveWeb3React } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nimport { filterTokens } from '../components/SearchModal/filtering';\nimport { arrayify } from 'ethers/lib/utils';\n\n// reduce token map into standard address <-> Token mapping, optionally include user added tokens\nfunction useTokensFromMap(tokenMap: TokenAddressMap, includeUserAdded: boolean): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n\n  return useMemo(() => {\n    if (!chainId) return {};\n\n    // reduce to just tokens\n    const mapWithoutUrls = Object.keys(tokenMap[chainId]).reduce<{ [address: string]: Token }>((newMap, address) => {\n      newMap[address] = tokenMap[chainId][address].token;\n      return newMap;\n    }, {});\n\n    if (includeUserAdded) {\n      return (\n        userAddedTokens\n          // reduce into all ALL_TOKENS filtered by the current chain\n          .reduce<{ [address: string]: Token }>(\n            (tokenMap, token) => {\n              tokenMap[token.address] = token;\n              return tokenMap;\n            },\n            // must make a copy because reduce modifies the map, and we do not\n            // want to make a copy in every iteration\n            { ...mapWithoutUrls }\n          )\n      );\n    }\n\n    return mapWithoutUrls;\n  }, [chainId, userAddedTokens, tokenMap, includeUserAdded]);\n}\n\nexport function useDefaultTokens(): { [address: string]: Token } {\n  const defaultList = useDefaultTokenList();\n  return useTokensFromMap(defaultList, false);\n}\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const allTokens = useCombinedActiveList();\n  return useTokensFromMap(allTokens, true);\n}\n\nexport function useAllInactiveTokens(): { [address: string]: Token } {\n  // get inactive tokens\n  const inactiveTokensMap = useCombinedInactiveList();\n  const inactiveTokens = useTokensFromMap(inactiveTokensMap, false);\n\n  // filter out any token that are on active list\n  const activeTokensAddresses = Object.keys(useAllTokens());\n  const filteredInactive = activeTokensAddresses\n    ? Object.keys(inactiveTokens).reduce<{ [address: string]: Token }>((newMap, address) => {\n        if (!activeTokensAddresses.includes(address)) {\n          newMap[address] = inactiveTokens[address];\n        }\n        return newMap;\n      }, {})\n    : inactiveTokens;\n\n  return filteredInactive;\n}\n\nexport function useIsTokenActive(token: Token | undefined | null): boolean {\n  const activeTokens = useAllTokens();\n\n  if (!activeTokens || !token) {\n    return false;\n  }\n\n  return !!activeTokens[token.address];\n}\n\n// used to detect extra search results\nexport function useFoundOnInactiveList(searchQuery: string): Token[] | undefined {\n  const { chainId } = useActiveWeb3React();\n  const inactiveTokens = useAllInactiveTokens();\n\n  return useMemo(() => {\n    if (!chainId || searchQuery === '') {\n      return undefined;\n    } else {\n      const tokens = filterTokens(Object.values(inactiveTokens), searchQuery);\n      return tokens;\n    }\n  }, [chainId, inactiveTokens, searchQuery]);\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency | undefined | null): boolean {\n  const userAddedTokens = useUserAddedTokens();\n\n  if (!currency) {\n    return false;\n  }\n\n  return !!userAddedTokens.find((token) => currencyEquals(currency, token));\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : // need to check for proper bytes string and valid terminator\n    bytes32 && BYTES32_REGEX.test(bytes32) && arrayify(bytes32)[31] === 0\n    ? parseBytes32String(bytes32)\n    : defaultValue;\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  const address = isAddress(tokenAddress);\n\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token: Token | undefined = address ? tokens[address] : undefined;\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  );\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'symbol',\n    undefined,\n    NEVER_RELOAD\n  );\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      );\n    }\n    return undefined;\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result,\n  ]);\n}\n\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === 'GAU';\n  const token = useToken(isETH ? undefined : currencyId);\n  return isETH ? ETHER : token;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
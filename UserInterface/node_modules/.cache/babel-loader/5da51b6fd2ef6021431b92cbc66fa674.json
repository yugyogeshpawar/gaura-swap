{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\nclass RequestError extends Error {\n  constructor(message, code, data) {\n    super(message);\n    this.code = code;\n    this.data = data;\n  }\n\n}\n\nclass MiniRpcProvider {\n  constructor(chainId, url, batchWaitTimeMs) {\n    this.isMetaMask = false;\n    this.chainId = void 0;\n    this.url = void 0;\n    this.host = void 0;\n    this.path = void 0;\n    this.batchWaitTimeMs = void 0;\n    this.nextId = 1;\n    this.batchTimeoutId = null;\n    this.batch = [];\n\n    this.clearBatch = async () => {\n      console.debug('Clearing batch', this.batch);\n      const batch = this.batch;\n      this.batch = [];\n      this.batchTimeoutId = null;\n      let response;\n\n      try {\n        response = await fetch(this.url, {\n          method: 'POST',\n          headers: {\n            'content-type': 'application/json',\n            accept: 'application/json'\n          },\n          body: JSON.stringify(batch.map(item => item.request))\n        });\n      } catch (error) {\n        batch.forEach(_ref => {\n          let {\n            reject\n          } = _ref;\n          return reject(new Error('Failed to send batch call'));\n        });\n        return;\n      }\n\n      if (!response.ok) {\n        batch.forEach(_ref2 => {\n          let {\n            reject\n          } = _ref2;\n          return reject(new RequestError(`${response.status}: ${response.statusText}`, -32000));\n        });\n        return;\n      }\n\n      let json;\n\n      try {\n        json = await response.json();\n      } catch (error) {\n        batch.forEach(_ref3 => {\n          let {\n            reject\n          } = _ref3;\n          return reject(new Error('Failed to parse JSON response'));\n        });\n        return;\n      }\n\n      const byKey = batch.reduce((memo, current) => {\n        memo[current.request.id] = current;\n        return memo;\n      }, {});\n\n      for (const result of json) {\n        const {\n          resolve,\n          reject,\n          request: {\n            method\n          }\n        } = byKey[result.id];\n\n        if (resolve && reject) {\n          if ('error' in result) {\n            var _result$error, _result$error2, _result$error3;\n\n            reject(new RequestError(result === null || result === void 0 ? void 0 : (_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.message, result === null || result === void 0 ? void 0 : (_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.code, result === null || result === void 0 ? void 0 : (_result$error3 = result.error) === null || _result$error3 === void 0 ? void 0 : _result$error3.data));\n          } else if ('result' in result) {\n            resolve(result.result);\n          } else {\n            reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n          }\n        }\n      }\n    };\n\n    this.sendAsync = (request, callback) => {\n      this.request(request.method, request.params).then(result => callback(null, {\n        jsonrpc: '2.0',\n        id: request.id,\n        result\n      })).catch(error => callback(error, null));\n    };\n\n    this.request = async (method, params) => {\n      var _this$batchTimeoutId;\n\n      if (typeof method !== 'string') {\n        return this.request(method.method, method.params);\n      }\n\n      if (method === 'eth_chainId') {\n        return `0x${this.chainId.toString(16)}`;\n      }\n\n      const promise = new Promise((resolve, reject) => {\n        this.batch.push({\n          request: {\n            jsonrpc: '2.0',\n            id: this.nextId++,\n            method,\n            params\n          },\n          resolve,\n          reject\n        });\n      });\n      this.batchTimeoutId = (_this$batchTimeoutId = this.batchTimeoutId) !== null && _this$batchTimeoutId !== void 0 ? _this$batchTimeoutId : setTimeout(this.clearBatch, this.batchWaitTimeMs);\n      return promise;\n    };\n\n    this.chainId = chainId;\n    this.url = url;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname; // how long to wait to batch calls\n\n    this.batchWaitTimeMs = batchWaitTimeMs !== null && batchWaitTimeMs !== void 0 ? batchWaitTimeMs : 50;\n  }\n\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  constructor(_ref4) {\n    let {\n      urls,\n      defaultChainId\n    } = _ref4;\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');\n    super({\n      supportedChainIds: Object.keys(urls).map(k => Number(k))\n    });\n    this.providers = void 0;\n    this.currentChainId = void 0;\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);\n    this.providers = Object.keys(urls).reduce((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);\n      return accumulator;\n    }, {});\n  }\n\n  get provider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async activate() {\n    return {\n      provider: this.providers[this.currentChainId],\n      chainId: this.currentChainId,\n      account: null\n    };\n  }\n\n  async getProvider() {\n    return this.providers[this.currentChainId];\n  }\n\n  async getChainId() {\n    return this.currentChainId;\n  }\n\n  async getAccount() {\n    return null;\n  }\n\n  deactivate() {\n    return;\n  }\n\n}","map":{"version":3,"names":["AbstractConnector","invariant","RequestError","Error","constructor","message","code","data","MiniRpcProvider","chainId","url","batchWaitTimeMs","isMetaMask","host","path","nextId","batchTimeoutId","batch","clearBatch","console","debug","response","fetch","method","headers","accept","body","JSON","stringify","map","item","request","error","forEach","reject","ok","status","statusText","json","byKey","reduce","memo","current","id","result","resolve","sendAsync","callback","params","then","jsonrpc","catch","toString","promise","Promise","push","setTimeout","parsed","URL","pathname","NetworkConnector","urls","defaultChainId","Object","keys","length","supportedChainIds","k","Number","providers","currentChainId","accumulator","provider","activate","account","getProvider","getChainId","getAccount","deactivate"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/connectors/NetworkConnector.ts"],"sourcesContent":["import { ConnectorUpdate } from '@web3-react/types';\nimport { AbstractConnector } from '@web3-react/abstract-connector';\nimport invariant from 'tiny-invariant';\n\ninterface NetworkConnectorArguments {\n  urls: { [chainId: number]: string };\n  defaultChainId?: number;\n}\n\n// taken from ethers.js, compatible interface with web3 provider\ntype AsyncSendable = {\n  isMetaMask?: boolean;\n  host?: string;\n  path?: string;\n  sendAsync?: (request: any, callback: (error: any, response: any) => void) => void;\n  send?: (request: any, callback: (error: any, response: any) => void) => void;\n};\n\nclass RequestError extends Error {\n  constructor(message: string, public code: number, public data?: unknown) {\n    super(message);\n  }\n}\n\ninterface BatchItem {\n  request: { jsonrpc: '2.0'; id: number; method: string; params: unknown };\n  resolve: (result: any) => void;\n  reject: (error: Error) => void;\n}\n\nclass MiniRpcProvider implements AsyncSendable {\n  public readonly isMetaMask: false = false;\n  public readonly chainId: number;\n  public readonly url: string;\n  public readonly host: string;\n  public readonly path: string;\n  public readonly batchWaitTimeMs: number;\n\n  private nextId = 1;\n  private batchTimeoutId: ReturnType<typeof setTimeout> | null = null;\n  private batch: BatchItem[] = [];\n\n  constructor(chainId: number, url: string, batchWaitTimeMs?: number) {\n    this.chainId = chainId;\n    this.url = url;\n    const parsed = new URL(url);\n    this.host = parsed.host;\n    this.path = parsed.pathname;\n    // how long to wait to batch calls\n    this.batchWaitTimeMs = batchWaitTimeMs ?? 50;\n  }\n\n  public readonly clearBatch = async () => {\n    console.debug('Clearing batch', this.batch);\n    const batch = this.batch;\n    this.batch = [];\n    this.batchTimeoutId = null;\n    let response: Response;\n    try {\n      response = await fetch(this.url, {\n        method: 'POST',\n        headers: { 'content-type': 'application/json', accept: 'application/json' },\n        body: JSON.stringify(batch.map((item) => item.request)),\n      });\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to send batch call')));\n      return;\n    }\n\n    if (!response.ok) {\n      batch.forEach(({ reject }) => reject(new RequestError(`${response.status}: ${response.statusText}`, -32000)));\n      return;\n    }\n\n    let json;\n    try {\n      json = await response.json();\n    } catch (error) {\n      batch.forEach(({ reject }) => reject(new Error('Failed to parse JSON response')));\n      return;\n    }\n    const byKey = batch.reduce<{ [id: number]: BatchItem }>((memo, current) => {\n      memo[current.request.id] = current;\n      return memo;\n    }, {});\n    for (const result of json) {\n      const {\n        resolve,\n        reject,\n        request: { method },\n      } = byKey[result.id];\n      if (resolve && reject) {\n        if ('error' in result) {\n          reject(new RequestError(result?.error?.message, result?.error?.code, result?.error?.data));\n        } else if ('result' in result) {\n          resolve(result.result);\n        } else {\n          reject(new RequestError(`Received unexpected JSON-RPC response to ${method} request.`, -32000, result));\n        }\n      }\n    }\n  };\n\n  public readonly sendAsync = (\n    request: { jsonrpc: '2.0'; id: number | string | null; method: string; params?: unknown[] | object },\n    callback: (error: any, response: any) => void\n  ): void => {\n    this.request(request.method, request.params)\n      .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))\n      .catch((error) => callback(error, null));\n  };\n\n  public readonly request = async (\n    method: string | { method: string; params: unknown[] },\n    params?: unknown[] | object\n  ): Promise<unknown> => {\n    if (typeof method !== 'string') {\n      return this.request(method.method, method.params);\n    }\n    if (method === 'eth_chainId') {\n      return `0x${this.chainId.toString(16)}`;\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.batch.push({\n        request: {\n          jsonrpc: '2.0',\n          id: this.nextId++,\n          method,\n          params,\n        },\n        resolve,\n        reject,\n      });\n    });\n    this.batchTimeoutId = this.batchTimeoutId ?? setTimeout(this.clearBatch, this.batchWaitTimeMs);\n    return promise;\n  };\n}\n\nexport class NetworkConnector extends AbstractConnector {\n  private readonly providers: { [chainId: number]: MiniRpcProvider };\n  private currentChainId: number;\n\n  constructor({ urls, defaultChainId }: NetworkConnectorArguments) {\n    invariant(defaultChainId || Object.keys(urls).length === 1, 'defaultChainId is a required argument with >1 url');\n    super({ supportedChainIds: Object.keys(urls).map((k): number => Number(k)) });\n\n    this.currentChainId = defaultChainId || Number(Object.keys(urls)[0]);\n    this.providers = Object.keys(urls).reduce<{ [chainId: number]: MiniRpcProvider }>((accumulator, chainId) => {\n      accumulator[Number(chainId)] = new MiniRpcProvider(Number(chainId), urls[Number(chainId)]);\n      return accumulator;\n    }, {});\n  }\n\n  public get provider(): MiniRpcProvider {\n    return this.providers[this.currentChainId];\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    return { provider: this.providers[this.currentChainId], chainId: this.currentChainId, account: null };\n  }\n\n  public async getProvider(): Promise<MiniRpcProvider> {\n    return this.providers[this.currentChainId];\n  }\n\n  public async getChainId(): Promise<number> {\n    return this.currentChainId;\n  }\n\n  public async getAccount(): Promise<null> {\n    return null;\n  }\n\n  public deactivate() {\n    return;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Pair, Token } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS, LP_TOKEN_NAME, LP_TOKEN_SYMBOL } from '../../constants';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { addSerializedPair, addSerializedToken, removeSerializedToken, updateUserDarkMode, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance, toggleURLWarning, updateUserSingleHopOnly } from './actions';\n\nfunction serializeToken(token) {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  };\n}\n\nfunction deserializeToken(serializedToken) {\n  return new Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);\n}\n\nexport function useIsDarkMode() {\n  const {\n    userDarkMode,\n    matchesDarkMode\n  } = useSelector(_ref => {\n    let {\n      user: {\n        matchesDarkMode,\n        userDarkMode\n      }\n    } = _ref;\n    return {\n      userDarkMode,\n      matchesDarkMode\n    };\n  }, shallowEqual);\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\nexport function useDarkModeManager() {\n  const dispatch = useDispatch();\n  const darkMode = useIsDarkMode();\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({\n      userDarkMode: !darkMode\n    }));\n  }, [darkMode, dispatch]);\n  return [darkMode, toggleSetDarkMode];\n}\nexport function useIsExpertMode() {\n  return useSelector(state => state.user.userExpertMode);\n}\nexport function useExpertModeManager() {\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\nexport function useUserSingleHopOnly() {\n  const dispatch = useDispatch();\n  const singleHopOnly = useSelector(state => state.user.userSingleHopOnly);\n  const setSingleHopOnly = useCallback(newSingleHopOnly => {\n    dispatch(updateUserSingleHopOnly({\n      userSingleHopOnly: newSingleHopOnly\n    }));\n  }, [dispatch]);\n  return [singleHopOnly, setSingleHopOnly];\n}\nexport function useUserSlippageTolerance() {\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(userSlippageTolerance => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\nexport function useUserTransactionTTL() {\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(userDeadline => {\n    dispatch(updateUserDeadline({\n      userDeadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\nexport function useAddUserToken() {\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\nexport function useRemoveUserAddedToken() {\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\nexport function useUserAddedTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const serializedTokensMap = useSelector(_ref2 => {\n    let {\n      user: {\n        tokens\n      }\n    } = _ref2;\n    return tokens;\n  });\n  return useMemo(() => {\n    var _serializedTokensMap;\n\n    if (!chainId) return [];\n    return Object.values((_serializedTokensMap = serializedTokensMap[chainId]) !== null && _serializedTokensMap !== void 0 ? _serializedTokensMap : {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\n\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\n\nexport function usePairAdder() {\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\nexport function useURLWarningVisible() {\n  return useSelector(state => state.user.URLWarningVisible);\n}\nexport function useURLWarningToggle() {\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\n\nexport function toV2LiquidityToken(_ref3) {\n  let [tokenA, tokenB] = _ref3;\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, LP_TOKEN_SYMBOL, LP_TOKEN_NAME);\n}\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\n\nexport function useTrackedTokenPairs() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens(); // pinned pairs\n\n  const pinnedPairs = useMemo(() => {\n    var _PINNED_PAIRS$chainId;\n\n    return chainId ? (_PINNED_PAIRS$chainId = PINNED_PAIRS[chainId]) !== null && _PINNED_PAIRS$chainId !== void 0 ? _PINNED_PAIRS$chainId : [] : [];\n  }, [chainId]); // pairs for every token against every base\n\n  const generatedPairs = useMemo(() => chainId ? flatMap(Object.keys(tokens), tokenAddress => {\n    var _BASES_TO_TRACK_LIQUI;\n\n    const token = tokens[tokenAddress]; // for each token on the current chain,\n\n    return (// loop though all bases on the current chain\n      ((_BASES_TO_TRACK_LIQUI = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _BASES_TO_TRACK_LIQUI !== void 0 ? _BASES_TO_TRACK_LIQUI : [] // to construct pairs of the given token with each base\n      ).map(base => {\n        if (base.address === token.address) {\n          return null;\n        } else {\n          return [base, token];\n        }\n      }).filter(p => p !== null)\n    );\n  }) : [], [tokens, chainId]); // pairs saved by users\n\n  const savedSerializedPairs = useSelector(_ref4 => {\n    let {\n      user: {\n        pairs\n      }\n    } = _ref4;\n    return pairs;\n  });\n  const userPairs = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce((memo, _ref5) => {\n      let [tokenA, tokenB] = _ref5;\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n    return Object.keys(keyed).map(key => keyed[key]);\n  }, [combinedList]);\n}","map":{"version":3,"names":["Pair","Token","flatMap","useCallback","useMemo","shallowEqual","useDispatch","useSelector","BASES_TO_TRACK_LIQUIDITY_FOR","PINNED_PAIRS","LP_TOKEN_NAME","LP_TOKEN_SYMBOL","useActiveWeb3React","useAllTokens","addSerializedPair","addSerializedToken","removeSerializedToken","updateUserDarkMode","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","toggleURLWarning","updateUserSingleHopOnly","serializeToken","token","chainId","address","decimals","symbol","name","deserializeToken","serializedToken","useIsDarkMode","userDarkMode","matchesDarkMode","user","useDarkModeManager","dispatch","darkMode","toggleSetDarkMode","useIsExpertMode","state","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSingleHopOnly","singleHopOnly","userSingleHopOnly","setSingleHopOnly","newSingleHopOnly","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","useUserTransactionTTL","userDeadline","setUserDeadline","useAddUserToken","useRemoveUserAddedToken","useUserAddedTokens","serializedTokensMap","tokens","Object","values","map","serializePair","pair","token0","token1","usePairAdder","serializedPair","useURLWarningVisible","URLWarningVisible","useURLWarningToggle","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs","pinnedPairs","generatedPairs","keys","tokenAddress","base","filter","p","savedSerializedPairs","pairs","userPairs","forChain","pairId","combinedList","concat","keyed","reduce","memo","sorted","sortsBefore","key"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/state/user/hooks.tsx"],"sourcesContent":["import { ChainId, Pair, Token } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS, LP_TOKEN_NAME, LP_TOKEN_SYMBOL } from '../../constants';\n\nimport { useActiveWeb3React } from '../../hooks';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { AppDispatch, AppState } from '../index';\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateUserDarkMode,\n  updateUserDeadline,\n  updateUserExpertMode,\n  updateUserSlippageTolerance,\n  toggleURLWarning,\n  updateUserSingleHopOnly,\n} from './actions';\n\nfunction serializeToken(token: Token): SerializedToken {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name,\n  };\n}\n\nfunction deserializeToken(serializedToken: SerializedToken): Token {\n  return new Token(\n    serializedToken.chainId,\n    serializedToken.address,\n    serializedToken.decimals,\n    serializedToken.symbol,\n    serializedToken.name\n  );\n}\n\nexport function useIsDarkMode(): boolean {\n  const { userDarkMode, matchesDarkMode } = useSelector<\n    AppState,\n    { userDarkMode: boolean | null; matchesDarkMode: boolean }\n  >(\n    ({ user: { matchesDarkMode, userDarkMode } }) => ({\n      userDarkMode,\n      matchesDarkMode,\n    }),\n    shallowEqual\n  );\n\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\n\nexport function useDarkModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const darkMode = useIsDarkMode();\n\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({ userDarkMode: !darkMode }));\n  }, [darkMode, dispatch]);\n\n  return [darkMode, toggleSetDarkMode];\n}\n\nexport function useIsExpertMode(): boolean {\n  return useSelector<AppState, AppState['user']['userExpertMode']>((state) => state.user.userExpertMode);\n}\n\nexport function useExpertModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const expertMode = useIsExpertMode();\n\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }));\n  }, [expertMode, dispatch]);\n\n  return [expertMode, toggleSetExpertMode];\n}\n\nexport function useUserSingleHopOnly(): [boolean, (newSingleHopOnly: boolean) => void] {\n  const dispatch = useDispatch<AppDispatch>();\n\n  const singleHopOnly = useSelector<AppState, AppState['user']['userSingleHopOnly']>(\n    (state) => state.user.userSingleHopOnly\n  );\n\n  const setSingleHopOnly = useCallback(\n    (newSingleHopOnly: boolean) => {\n      dispatch(updateUserSingleHopOnly({ userSingleHopOnly: newSingleHopOnly }));\n    },\n    [dispatch]\n  );\n\n  return [singleHopOnly, setSingleHopOnly];\n}\n\nexport function useUserSlippageTolerance(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userSlippageTolerance = useSelector<AppState, AppState['user']['userSlippageTolerance']>((state) => {\n    return state.user.userSlippageTolerance;\n  });\n\n  const setUserSlippageTolerance = useCallback(\n    (userSlippageTolerance: number) => {\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance }));\n    },\n    [dispatch]\n  );\n\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\n\nexport function useUserTransactionTTL(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>();\n  const userDeadline = useSelector<AppState, AppState['user']['userDeadline']>((state) => {\n    return state.user.userDeadline;\n  });\n\n  const setUserDeadline = useCallback(\n    (userDeadline: number) => {\n      dispatch(updateUserDeadline({ userDeadline }));\n    },\n    [dispatch]\n  );\n\n  return [userDeadline, setUserDeadline];\n}\n\nexport function useAddUserToken(): (token: Token) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (token: Token) => {\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useRemoveUserAddedToken(): (chainId: number, address: string) => void {\n  const dispatch = useDispatch<AppDispatch>();\n  return useCallback(\n    (chainId: number, address: string) => {\n      dispatch(removeSerializedToken({ chainId, address }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useUserAddedTokens(): Token[] {\n  const { chainId } = useActiveWeb3React();\n  const serializedTokensMap = useSelector<AppState, AppState['user']['tokens']>(({ user: { tokens } }) => tokens);\n\n  return useMemo(() => {\n    if (!chainId) return [];\n    return Object.values(serializedTokensMap[chainId as ChainId] ?? {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\n\nfunction serializePair(pair: Pair): SerializedPair {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1),\n  };\n}\n\nexport function usePairAdder(): (pair: Pair) => void {\n  const dispatch = useDispatch<AppDispatch>();\n\n  return useCallback(\n    (pair: Pair) => {\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }));\n    },\n    [dispatch]\n  );\n}\n\nexport function useURLWarningVisible(): boolean {\n  return useSelector((state: AppState) => state.user.URLWarningVisible);\n}\n\nexport function useURLWarningToggle(): () => void {\n  const dispatch = useDispatch();\n  return useCallback(() => dispatch(toggleURLWarning()), [dispatch]);\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, LP_TOKEN_SYMBOL, LP_TOKEN_NAME);\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs(): [Token, Token][] {\n  const { chainId } = useActiveWeb3React();\n  const tokens = useAllTokens();\n\n  // pinned pairs\n  const pinnedPairs = useMemo(() => (chainId ? PINNED_PAIRS[chainId] ?? [] : []), [chainId]);\n\n  // pairs for every token against every base\n  const generatedPairs: [Token, Token][] = useMemo(\n    () =>\n      chainId\n        ? flatMap(Object.keys(tokens), (tokenAddress) => {\n            const token = tokens[tokenAddress];\n            // for each token on the current chain,\n            return (\n              // loop though all bases on the current chain\n              (BASES_TO_TRACK_LIQUIDITY_FOR[chainId] ?? [])\n                // to construct pairs of the given token with each base\n                .map((base) => {\n                  if (base.address === token.address) {\n                    return null;\n                  } else {\n                    return [base, token];\n                  }\n                })\n                .filter((p): p is [Token, Token] => p !== null)\n            );\n          })\n        : [],\n    [tokens, chainId]\n  );\n\n  // pairs saved by users\n  const savedSerializedPairs = useSelector<AppState, AppState['user']['pairs']>(({ user: { pairs } }) => pairs);\n\n  const userPairs: [Token, Token][] = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n\n    return Object.keys(forChain).map((pairId) => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n\n  const combinedList = useMemo(\n    () => userPairs.concat(generatedPairs).concat(pinnedPairs),\n    [generatedPairs, pinnedPairs, userPairs]\n  );\n\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce<{ [key: string]: [Token, Token] }>((memo, [tokenA, tokenB]) => {\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n\n    return Object.keys(keyed).map((key) => keyed[key]);\n  }, [combinedList]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
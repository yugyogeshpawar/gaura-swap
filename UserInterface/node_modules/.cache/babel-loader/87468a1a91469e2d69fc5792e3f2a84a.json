{"ast":null,"code":"/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\n\nvar parseTag = require('./parse-tag'); // re-used obj for quick lookups of components\n\n\nvar empty = Object.create ? Object.create(null) : {}; // common logic for pushing a child node onto a list\n\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  var end = html.indexOf('<', start);\n  var content = html.slice(start, end === -1 ? undefined : end); // if a node is nothing but whitespace, collapse it as the spec states:\n  // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n\n  if (/^\\s*$/.test(content)) {\n    content = ' ';\n  } // don't add whitespace-only text nodes if they would be trailing text nodes\n  // or if they would be leading whitespace-only text nodes:\n  //  * end > -1 indicates this is not a trailing text node\n  //  * leading node is when level is -1 and list has length 0\n\n\n  if (!ignoreWhitespace && end > -1 && level + list.length >= 0 || content !== ' ') {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\n\nmodule.exports = function parse(html, options) {\n  options || (options = {});\n  options.components || (options.components = empty);\n  var result = [];\n  var current;\n  var level = -1;\n  var arr = [];\n  var byTag = {};\n  var inComponent = false;\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return;\n      } else {\n        inComponent = false;\n      }\n    }\n\n    var isOpen = tag.charAt(1) !== '/';\n    var isComment = tag.indexOf('<!--') === 0;\n    var start = index + tag.length;\n    var nextChar = html.charAt(start);\n    var parent;\n\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component';\n        inComponent = true;\n      }\n\n      if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n      }\n\n      byTag[current.tagName] = current; // if we're at root, push new base node\n\n      if (level === 0) {\n        result.push(current);\n      }\n\n      parent = arr[level - 1];\n\n      if (parent) {\n        parent.children.push(current);\n      }\n\n      arr[level] = current;\n    }\n\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n      }\n    }\n  }); // If the \"html\" passed isn't actually html, add it as a text node.\n\n  if (!result.length && html.length) {\n    pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n  }\n\n  return result;\n};","map":{"version":3,"names":["tagRE","parseTag","require","empty","Object","create","pushTextNode","list","html","level","start","ignoreWhitespace","end","indexOf","content","slice","undefined","test","length","push","type","module","exports","parse","options","components","result","current","arr","byTag","inComponent","replace","tag","index","name","isOpen","charAt","isComment","nextChar","parent","voidElement","children","tagName"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/node_modules/html-parse-stringify2/lib/parse.js"],"sourcesContent":["/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nvar parseTag = require('./parse-tag');\n// re-used obj for quick lookups of components\nvar empty = Object.create ? Object.create(null) : {};\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n    // calculate correct end of the content slice in case there's\n    // no tag after the text node.\n    var end = html.indexOf('<', start);\n    var content = html.slice(start, end === -1 ? undefined : end);\n    // if a node is nothing but whitespace, collapse it as the spec states:\n    // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n    if (/^\\s*$/.test(content)) {\n        content = ' ';\n    }\n    // don't add whitespace-only text nodes if they would be trailing text nodes\n    // or if they would be leading whitespace-only text nodes:\n    //  * end > -1 indicates this is not a trailing text node\n    //  * leading node is when level is -1 and list has length 0\n    if ((!ignoreWhitespace && end > -1 && level + list.length >= 0) || content !== ' ') {\n        list.push({\n            type: 'text',\n            content: content\n        });\n    }\n}\n\nmodule.exports = function parse(html, options) {\n    options || (options = {});\n    options.components || (options.components = empty);\n    var result = [];\n    var current;\n    var level = -1;\n    var arr = [];\n    var byTag = {};\n    var inComponent = false;\n\n    html.replace(tagRE, function (tag, index) {\n        if (inComponent) {\n            if (tag !== ('</' + current.name + '>')) {\n                return;\n            } else {\n                inComponent = false;\n            }\n        }\n\n        var isOpen = tag.charAt(1) !== '/';\n        var isComment = tag.indexOf('<!--') === 0;\n        var start = index + tag.length;\n        var nextChar = html.charAt(start);\n        var parent;\n\n        if (isOpen && !isComment) {\n            level++;\n\n            current = parseTag(tag);\n            if (current.type === 'tag' && options.components[current.name]) {\n                current.type = 'component';\n                inComponent = true;\n            }\n\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n                pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n            }\n\n            byTag[current.tagName] = current;\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current);\n            }\n\n            parent = arr[level - 1];\n\n            if (parent) {\n                parent.children.push(current);\n            }\n\n            arr[level] = current;\n        }\n\n        if (isComment || !isOpen || current.voidElement) {\n            if (!isComment) {\n                level--;\n            }\n            if (!inComponent && nextChar !== '<' && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].children;\n                pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n            }\n        }\n    });\n\n    // If the \"html\" passed isn't actually html, add it as a text node.\n    if (!result.length && html.length) {\n        pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n    }\n\n    return result;\n};\n"],"mappings":"AAAA;AACA,IAAIA,KAAK,GAAG,8DAAZ;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAtB,C,CACA;;;AACA,IAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,GAAgBD,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB,GAAsC,EAAlD,C,CACA;;AACA,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,KAAlC,EAAyCC,KAAzC,EAAgDC,gBAAhD,EAAkE;EAC9D;EACA;EACA,IAAIC,GAAG,GAAGJ,IAAI,CAACK,OAAL,CAAa,GAAb,EAAkBH,KAAlB,CAAV;EACA,IAAII,OAAO,GAAGN,IAAI,CAACO,KAAL,CAAWL,KAAX,EAAkBE,GAAG,KAAK,CAAC,CAAT,GAAaI,SAAb,GAAyBJ,GAA3C,CAAd,CAJ8D,CAK9D;EACA;;EACA,IAAI,QAAQK,IAAR,CAAaH,OAAb,CAAJ,EAA2B;IACvBA,OAAO,GAAG,GAAV;EACH,CAT6D,CAU9D;EACA;EACA;EACA;;;EACA,IAAK,CAACH,gBAAD,IAAqBC,GAAG,GAAG,CAAC,CAA5B,IAAiCH,KAAK,GAAGF,IAAI,CAACW,MAAb,IAAuB,CAAzD,IAA+DJ,OAAO,KAAK,GAA/E,EAAoF;IAChFP,IAAI,CAACY,IAAL,CAAU;MACNC,IAAI,EAAE,MADA;MAENN,OAAO,EAAEA;IAFH,CAAV;EAIH;AACJ;;AAEDO,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAef,IAAf,EAAqBgB,OAArB,EAA8B;EAC3CA,OAAO,KAAKA,OAAO,GAAG,EAAf,CAAP;EACAA,OAAO,CAACC,UAAR,KAAuBD,OAAO,CAACC,UAAR,GAAqBtB,KAA5C;EACA,IAAIuB,MAAM,GAAG,EAAb;EACA,IAAIC,OAAJ;EACA,IAAIlB,KAAK,GAAG,CAAC,CAAb;EACA,IAAImB,GAAG,GAAG,EAAV;EACA,IAAIC,KAAK,GAAG,EAAZ;EACA,IAAIC,WAAW,GAAG,KAAlB;EAEAtB,IAAI,CAACuB,OAAL,CAAa/B,KAAb,EAAoB,UAAUgC,GAAV,EAAeC,KAAf,EAAsB;IACtC,IAAIH,WAAJ,EAAiB;MACb,IAAIE,GAAG,KAAM,OAAOL,OAAO,CAACO,IAAf,GAAsB,GAAnC,EAAyC;QACrC;MACH,CAFD,MAEO;QACHJ,WAAW,GAAG,KAAd;MACH;IACJ;;IAED,IAAIK,MAAM,GAAGH,GAAG,CAACI,MAAJ,CAAW,CAAX,MAAkB,GAA/B;IACA,IAAIC,SAAS,GAAGL,GAAG,CAACnB,OAAJ,CAAY,MAAZ,MAAwB,CAAxC;IACA,IAAIH,KAAK,GAAGuB,KAAK,GAAGD,GAAG,CAACd,MAAxB;IACA,IAAIoB,QAAQ,GAAG9B,IAAI,CAAC4B,MAAL,CAAY1B,KAAZ,CAAf;IACA,IAAI6B,MAAJ;;IAEA,IAAIJ,MAAM,IAAI,CAACE,SAAf,EAA0B;MACtB5B,KAAK;MAELkB,OAAO,GAAG1B,QAAQ,CAAC+B,GAAD,CAAlB;;MACA,IAAIL,OAAO,CAACP,IAAR,KAAiB,KAAjB,IAA0BI,OAAO,CAACC,UAAR,CAAmBE,OAAO,CAACO,IAA3B,CAA9B,EAAgE;QAC5DP,OAAO,CAACP,IAAR,GAAe,WAAf;QACAU,WAAW,GAAG,IAAd;MACH;;MAED,IAAI,CAACH,OAAO,CAACa,WAAT,IAAwB,CAACV,WAAzB,IAAwCQ,QAAxC,IAAoDA,QAAQ,KAAK,GAArE,EAA0E;QACtEhC,YAAY,CAACqB,OAAO,CAACc,QAAT,EAAmBjC,IAAnB,EAAyBC,KAAzB,EAAgCC,KAAhC,EAAuCc,OAAO,CAACb,gBAA/C,CAAZ;MACH;;MAEDkB,KAAK,CAACF,OAAO,CAACe,OAAT,CAAL,GAAyBf,OAAzB,CAbsB,CAetB;;MACA,IAAIlB,KAAK,KAAK,CAAd,EAAiB;QACbiB,MAAM,CAACP,IAAP,CAAYQ,OAAZ;MACH;;MAEDY,MAAM,GAAGX,GAAG,CAACnB,KAAK,GAAG,CAAT,CAAZ;;MAEA,IAAI8B,MAAJ,EAAY;QACRA,MAAM,CAACE,QAAP,CAAgBtB,IAAhB,CAAqBQ,OAArB;MACH;;MAEDC,GAAG,CAACnB,KAAD,CAAH,GAAakB,OAAb;IACH;;IAED,IAAIU,SAAS,IAAI,CAACF,MAAd,IAAwBR,OAAO,CAACa,WAApC,EAAiD;MAC7C,IAAI,CAACH,SAAL,EAAgB;QACZ5B,KAAK;MACR;;MACD,IAAI,CAACqB,WAAD,IAAgBQ,QAAQ,KAAK,GAA7B,IAAoCA,QAAxC,EAAkD;QAC9C;QACA;QACA;QACAC,MAAM,GAAG9B,KAAK,KAAK,CAAC,CAAX,GAAeiB,MAAf,GAAwBE,GAAG,CAACnB,KAAD,CAAH,CAAWgC,QAA5C;QACAnC,YAAY,CAACiC,MAAD,EAAS/B,IAAT,EAAeC,KAAf,EAAsBC,KAAtB,EAA6Bc,OAAO,CAACb,gBAArC,CAAZ;MACH;IACJ;EACJ,CAxDD,EAV2C,CAoE3C;;EACA,IAAI,CAACe,MAAM,CAACR,MAAR,IAAkBV,IAAI,CAACU,MAA3B,EAAmC;IAC/BZ,YAAY,CAACoB,MAAD,EAASlB,IAAT,EAAe,CAAf,EAAkB,CAAlB,EAAqBgB,OAAO,CAACb,gBAA7B,CAAZ;EACH;;EAED,OAAOe,MAAP;AACH,CA1ED"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import { isTradeBetter } from 'utils/trades';\nimport { Trade } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const bases = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])).filter(_ref => {\n    let [t0, t1] = _ref;\n    return t0.address !== t1.address;\n  }), [bases]);\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(_ref2 => {\n    let [t0, t1] = _ref2;\n    return t0.address !== t1.address;\n  }).filter(_ref3 => {\n    let [tokenA, tokenB] = _ref3;\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    if (!customBases) return true;\n    const customBasesA = customBases[tokenA.address];\n    const customBasesB = customBases[tokenB.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => tokenB.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => tokenA.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, _ref4) => {\n    var _memo$curr$liquidityT;\n\n    let [, curr] = _ref4;\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n\nconst MAX_HOPS = 3;\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact;\n\n        return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact2;\n\n        const currentTrade = (_Trade$bestTradeExact2 = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null; // if current trade is best yet, save it\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  const [singleHopOnly] = useUserSingleHopOnly();\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        var _Trade$bestTradeExact3;\n\n        return (_Trade$bestTradeExact3 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: 1,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact3 !== void 0 ? _Trade$bestTradeExact3 : null;\n      } // search through trades with varying hops, find best trade out of them\n\n\n      let bestTradeSoFar = null;\n\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        var _Trade$bestTradeExact4;\n\n        const currentTrade = (_Trade$bestTradeExact4 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n          maxHops: i,\n          maxNumResults: 1\n        })[0]) !== null && _Trade$bestTradeExact4 !== void 0 ? _Trade$bestTradeExact4 : null;\n\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}","map":{"version":3,"names":["isTradeBetter","Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","BETTER_TRADE_LESS_HOPS_THRESHOLD","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useUserSingleHopOnly","useAllCommonPairs","currencyA","currencyB","chainId","bases","tokenA","tokenB","undefined","basePairs","base","map","otherBase","filter","t0","t1","address","allPairCombinations","tokens","Boolean","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/hooks/Trades.ts"],"sourcesContent":["import { isTradeBetter } from 'utils/trades';\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\n\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES, BETTER_TRADE_LESS_HOPS_THRESHOLD } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\n\nimport { useActiveWeb3React } from './index';\nimport { useUserSingleHopOnly } from 'state/user/hooks';\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React();\n\n  const bases: Token[] = chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [];\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined];\n\n  const basePairs: [Token, Token][] = useMemo(\n    () =>\n      flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])).filter(\n        ([t0, t1]) => t0.address !== t1.address\n      ),\n    [bases]\n  );\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n            .filter(([tokenA, tokenB]) => {\n              if (!chainId) return true;\n              const customBases = CUSTOM_BASES[chainId];\n              if (!customBases) return true;\n\n              const customBasesA: Token[] | undefined = customBases[tokenA.address];\n              const customBasesB: Token[] | undefined = customBases[tokenB.address];\n\n              if (!customBasesA && !customBasesB) return true;\n\n              if (customBasesA && !customBasesA.find((base) => tokenB.equals(base))) return false;\n              if (customBasesB && !customBasesB.find((base) => tokenA.equals(base))) return false;\n\n              return true;\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId]\n  );\n\n  const allPairs = usePairs(allPairCombinations);\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr;\n            return memo;\n          }, {})\n      ),\n    [allPairs]\n  );\n}\n\nconst MAX_HOPS = 3;\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut);\n\n  const [singleHopOnly] = useUserSingleHopOnly();\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        );\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null;\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly]);\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency);\n\n  const [singleHopOnly] = useUserSingleHopOnly();\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        );\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null;\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null;\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade;\n        }\n      }\n      return bestTradeSoFar;\n    }\n    return null;\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
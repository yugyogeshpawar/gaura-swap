{"ast":null,"code":"import { CurrencyAmount, ETHER, JSBI, Percent, Price } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\nimport { useActiveWeb3React } from '../../hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\nconst ZERO = JSBI.BigInt(0);\nexport function useMintState() {\n  return useSelector(state => state.mint);\n}\nexport function useMintActionHandlers(noLiquidity) {\n  const dispatch = useDispatch();\n  const onFieldAInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_A,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  const onFieldBInput = useCallback(typedValue => {\n    dispatch(typeInput({\n      field: Field.CURRENCY_B,\n      typedValue,\n      noLiquidity: noLiquidity === true\n    }));\n  }, [dispatch, noLiquidity]);\n  return {\n    onFieldAInput,\n    onFieldBInput\n  };\n}\nexport function useDerivedMintInfo(currencyA, currencyB) {\n  var _currencyBalances$Fie, _currencyBalances$Fie2;\n\n  const {\n    account,\n    chainId\n  } = useActiveWeb3React();\n  const {\n    independentField,\n    typedValue,\n    otherTypedValue\n  } = useMintState();\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A; // tokens\n\n  const currencies = useMemo(() => ({\n    [Field.CURRENCY_A]: currencyA !== null && currencyA !== void 0 ? currencyA : undefined,\n    [Field.CURRENCY_B]: currencyB !== null && currencyB !== void 0 ? currencyB : undefined\n  }), [currencyA, currencyB]); // pair\n\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair === null || pair === void 0 ? void 0 : pair.liquidityToken);\n  const noLiquidity = pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO)); // balances\n\n  const balances = useCurrencyBalances(account !== null && account !== void 0 ? account : undefined, [currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]]);\n  const currencyBalances = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1]\n  }; // amounts\n\n  const independentAmount = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\n\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount = dependentField === Field.CURRENCY_B ? pair.priceOf(tokenA).quote(wrappedIndependentAmount) : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\n      }\n\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [noLiquidity, otherTypedValue, currencies, dependentField, independentAmount, currencyA, chainId, currencyB, pair]);\n  const parsedAmounts = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount\n  };\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const {\n        [Field.CURRENCY_A]: currencyAAmount,\n        [Field.CURRENCY_B]: currencyBAmount\n      } = parsedAmounts;\n\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n\n      return undefined;\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]); // liquidity minted\n\n  const liquidityMinted = useMemo(() => {\n    const {\n      [Field.CURRENCY_A]: currencyAAmount,\n      [Field.CURRENCY_B]: currencyBAmount\n    } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [wrappedCurrencyAmount(currencyAAmount, chainId), wrappedCurrencyAmount(currencyBAmount, chainId)];\n\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n  let error;\n\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (pairState === PairState.INVALID) {\n    var _error;\n\n    error = (_error = error) !== null && _error !== void 0 ? _error : 'Invalid pair';\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    var _error2;\n\n    error = (_error2 = error) !== null && _error2 !== void 0 ? _error2 : 'Enter an amount';\n  }\n\n  const {\n    [Field.CURRENCY_A]: currencyAAmount,\n    [Field.CURRENCY_B]: currencyBAmount\n  } = parsedAmounts;\n\n  if (currencyAAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie = currencyBalances[Field.CURRENCY_A]) === null || _currencyBalances$Fie === void 0 ? void 0 : _currencyBalances$Fie.lessThan(currencyAAmount))) {\n    var _currencies$Field$CUR;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR = currencies[Field.CURRENCY_A]) === null || _currencies$Field$CUR === void 0 ? void 0 : _currencies$Field$CUR.symbol) + ' balance';\n  }\n\n  if (currencyBAmount && (currencyBalances === null || currencyBalances === void 0 ? void 0 : (_currencyBalances$Fie2 = currencyBalances[Field.CURRENCY_B]) === null || _currencyBalances$Fie2 === void 0 ? void 0 : _currencyBalances$Fie2.lessThan(currencyBAmount))) {\n    var _currencies$Field$CUR2;\n\n    error = 'Insufficient ' + ((_currencies$Field$CUR2 = currencies[Field.CURRENCY_B]) === null || _currencies$Field$CUR2 === void 0 ? void 0 : _currencies$Field$CUR2.symbol) + ' balance';\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error\n  };\n}","map":{"version":3,"names":["CurrencyAmount","ETHER","JSBI","Percent","Price","useCallback","useMemo","useDispatch","useSelector","PairState","usePair","useTotalSupply","useActiveWeb3React","wrappedCurrency","wrappedCurrencyAmount","tryParseAmount","useCurrencyBalances","Field","typeInput","ZERO","BigInt","useMintState","state","mint","useMintActionHandlers","noLiquidity","dispatch","onFieldAInput","typedValue","field","CURRENCY_A","onFieldBInput","CURRENCY_B","useDerivedMintInfo","currencyA","currencyB","account","chainId","independentField","otherTypedValue","dependentField","currencies","undefined","pairState","pair","totalSupply","liquidityToken","NOT_EXISTS","Boolean","equal","raw","balances","currencyBalances","independentAmount","dependentAmount","wrappedIndependentAmount","tokenA","tokenB","dependentCurrency","dependentTokenAmount","priceOf","quote","ether","parsedAmounts","price","currencyAAmount","currencyBAmount","currency","wrappedCurrencyA","liquidityMinted","tokenAmountA","tokenAmountB","getLiquidityMinted","poolTokenPercentage","add","error","INVALID","lessThan","symbol"],"sources":["/Users/vaibhav/Desktop/Home/Blockchain Boutique/Uniswap_forked_gaura/src/state/mint/hooks.ts"],"sourcesContent":["import { Currency, CurrencyAmount, ETHER, JSBI, Pair, Percent, Price, TokenAmount } from '@uniswap/sdk';\nimport { useCallback, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { PairState, usePair } from '../../data/Reserves';\nimport { useTotalSupply } from '../../data/TotalSupply';\n\nimport { useActiveWeb3React } from '../../hooks';\nimport { wrappedCurrency, wrappedCurrencyAmount } from '../../utils/wrappedCurrency';\nimport { AppDispatch, AppState } from '../index';\nimport { tryParseAmount } from '../swap/hooks';\nimport { useCurrencyBalances } from '../wallet/hooks';\nimport { Field, typeInput } from './actions';\n\nconst ZERO = JSBI.BigInt(0);\n\nexport function useMintState(): AppState['mint'] {\n  return useSelector<AppState, AppState['mint']>((state) => state.mint);\n}\n\nexport function useMintActionHandlers(noLiquidity: boolean | undefined): {\n  onFieldAInput: (typedValue: string) => void;\n  onFieldBInput: (typedValue: string) => void;\n} {\n  const dispatch = useDispatch<AppDispatch>();\n\n  const onFieldAInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_A, typedValue, noLiquidity: noLiquidity === true }));\n    },\n    [dispatch, noLiquidity]\n  );\n  const onFieldBInput = useCallback(\n    (typedValue: string) => {\n      dispatch(typeInput({ field: Field.CURRENCY_B, typedValue, noLiquidity: noLiquidity === true }));\n    },\n    [dispatch, noLiquidity]\n  );\n\n  return {\n    onFieldAInput,\n    onFieldBInput,\n  };\n}\n\nexport function useDerivedMintInfo(\n  currencyA: Currency | undefined,\n  currencyB: Currency | undefined\n): {\n  dependentField: Field;\n  currencies: { [field in Field]?: Currency };\n  pair?: Pair | null;\n  pairState: PairState;\n  currencyBalances: { [field in Field]?: CurrencyAmount };\n  parsedAmounts: { [field in Field]?: CurrencyAmount };\n  price?: Price;\n  noLiquidity?: boolean;\n  liquidityMinted?: TokenAmount;\n  poolTokenPercentage?: Percent;\n  error?: string;\n} {\n  const { account, chainId } = useActiveWeb3React();\n\n  const { independentField, typedValue, otherTypedValue } = useMintState();\n\n  const dependentField = independentField === Field.CURRENCY_A ? Field.CURRENCY_B : Field.CURRENCY_A;\n\n  // tokens\n  const currencies: { [field in Field]?: Currency } = useMemo(\n    () => ({\n      [Field.CURRENCY_A]: currencyA ?? undefined,\n      [Field.CURRENCY_B]: currencyB ?? undefined,\n    }),\n    [currencyA, currencyB]\n  );\n\n  // pair\n  const [pairState, pair] = usePair(currencies[Field.CURRENCY_A], currencies[Field.CURRENCY_B]);\n  const totalSupply = useTotalSupply(pair?.liquidityToken);\n\n  const noLiquidity: boolean =\n    pairState === PairState.NOT_EXISTS || Boolean(totalSupply && JSBI.equal(totalSupply.raw, ZERO));\n\n  // balances\n  const balances = useCurrencyBalances(account ?? undefined, [\n    currencies[Field.CURRENCY_A],\n    currencies[Field.CURRENCY_B],\n  ]);\n  const currencyBalances: { [field in Field]?: CurrencyAmount } = {\n    [Field.CURRENCY_A]: balances[0],\n    [Field.CURRENCY_B]: balances[1],\n  };\n\n  // amounts\n  const independentAmount: CurrencyAmount | undefined = tryParseAmount(typedValue, currencies[independentField]);\n  const dependentAmount: CurrencyAmount | undefined = useMemo(() => {\n    if (noLiquidity) {\n      if (otherTypedValue && currencies[dependentField]) {\n        return tryParseAmount(otherTypedValue, currencies[dependentField]);\n      }\n      return undefined;\n    } else if (independentAmount) {\n      // we wrap the currencies just to get the price in terms of the other token\n      const wrappedIndependentAmount = wrappedCurrencyAmount(independentAmount, chainId);\n      const [tokenA, tokenB] = [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)];\n      if (tokenA && tokenB && wrappedIndependentAmount && pair) {\n        const dependentCurrency = dependentField === Field.CURRENCY_B ? currencyB : currencyA;\n        const dependentTokenAmount =\n          dependentField === Field.CURRENCY_B\n            ? pair.priceOf(tokenA).quote(wrappedIndependentAmount)\n            : pair.priceOf(tokenB).quote(wrappedIndependentAmount);\n        return dependentCurrency === ETHER ? CurrencyAmount.ether(dependentTokenAmount.raw) : dependentTokenAmount;\n      }\n      return undefined;\n    } else {\n      return undefined;\n    }\n  }, [\n    noLiquidity,\n    otherTypedValue,\n    currencies,\n    dependentField,\n    independentAmount,\n    currencyA,\n    chainId,\n    currencyB,\n    pair,\n  ]);\n  const parsedAmounts: { [field in Field]: CurrencyAmount | undefined } = {\n    [Field.CURRENCY_A]: independentField === Field.CURRENCY_A ? independentAmount : dependentAmount,\n    [Field.CURRENCY_B]: independentField === Field.CURRENCY_A ? dependentAmount : independentAmount,\n  };\n\n  const price = useMemo(() => {\n    if (noLiquidity) {\n      const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n      if (currencyAAmount && currencyBAmount) {\n        return new Price(currencyAAmount.currency, currencyBAmount.currency, currencyAAmount.raw, currencyBAmount.raw);\n      }\n      return undefined;\n    } else {\n      const wrappedCurrencyA = wrappedCurrency(currencyA, chainId);\n      return pair && wrappedCurrencyA ? pair.priceOf(wrappedCurrencyA) : undefined;\n    }\n  }, [chainId, currencyA, noLiquidity, pair, parsedAmounts]);\n\n  // liquidity minted\n  const liquidityMinted = useMemo(() => {\n    const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n    const [tokenAmountA, tokenAmountB] = [\n      wrappedCurrencyAmount(currencyAAmount, chainId),\n      wrappedCurrencyAmount(currencyBAmount, chainId),\n    ];\n    if (pair && totalSupply && tokenAmountA && tokenAmountB) {\n      return pair.getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB);\n    } else {\n      return undefined;\n    }\n  }, [parsedAmounts, chainId, pair, totalSupply]);\n\n  const poolTokenPercentage = useMemo(() => {\n    if (liquidityMinted && totalSupply) {\n      return new Percent(liquidityMinted.raw, totalSupply.add(liquidityMinted).raw);\n    } else {\n      return undefined;\n    }\n  }, [liquidityMinted, totalSupply]);\n\n  let error: string | undefined;\n  if (!account) {\n    error = 'Connect Wallet';\n  }\n\n  if (pairState === PairState.INVALID) {\n    error = error ?? 'Invalid pair';\n  }\n\n  if (!parsedAmounts[Field.CURRENCY_A] || !parsedAmounts[Field.CURRENCY_B]) {\n    error = error ?? 'Enter an amount';\n  }\n\n  const { [Field.CURRENCY_A]: currencyAAmount, [Field.CURRENCY_B]: currencyBAmount } = parsedAmounts;\n\n  if (currencyAAmount && currencyBalances?.[Field.CURRENCY_A]?.lessThan(currencyAAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_A]?.symbol + ' balance';\n  }\n\n  if (currencyBAmount && currencyBalances?.[Field.CURRENCY_B]?.lessThan(currencyBAmount)) {\n    error = 'Insufficient ' + currencies[Field.CURRENCY_B]?.symbol + ' balance';\n  }\n\n  return {\n    dependentField,\n    currencies,\n    pair,\n    pairState,\n    currencyBalances,\n    parsedAmounts,\n    price,\n    noLiquidity,\n    liquidityMinted,\n    poolTokenPercentage,\n    error,\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}